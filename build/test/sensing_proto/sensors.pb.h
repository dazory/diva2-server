// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensors_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensors_2eproto;
namespace sensors {
class Cam;
struct CamDefaultTypeInternal;
extern CamDefaultTypeInternal _Cam_default_instance_;
class Can;
struct CanDefaultTypeInternal;
extern CanDefaultTypeInternal _Can_default_instance_;
class Gps;
struct GpsDefaultTypeInternal;
extern GpsDefaultTypeInternal _Gps_default_instance_;
class Imu;
struct ImuDefaultTypeInternal;
extern ImuDefaultTypeInternal _Imu_default_instance_;
class Lidar;
struct LidarDefaultTypeInternal;
extern LidarDefaultTypeInternal _Lidar_default_instance_;
}  // namespace sensors
PROTOBUF_NAMESPACE_OPEN
template<> ::sensors::Cam* Arena::CreateMaybeMessage<::sensors::Cam>(Arena*);
template<> ::sensors::Can* Arena::CreateMaybeMessage<::sensors::Can>(Arena*);
template<> ::sensors::Gps* Arena::CreateMaybeMessage<::sensors::Gps>(Arena*);
template<> ::sensors::Imu* Arena::CreateMaybeMessage<::sensors::Imu>(Arena*);
template<> ::sensors::Lidar* Arena::CreateMaybeMessage<::sensors::Lidar>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensors {

// ===================================================================

class Gps PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Gps) */ {
 public:
  inline Gps() : Gps(nullptr) {}
  ~Gps() override;
  explicit constexpr Gps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gps(const Gps& from);
  Gps(Gps&& from) noexcept
    : Gps() {
    *this = ::std::move(from);
  }

  inline Gps& operator=(const Gps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gps& operator=(Gps&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gps* internal_default_instance() {
    return reinterpret_cast<const Gps*>(
               &_Gps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Gps& a, Gps& b) {
    a.Swap(&b);
  }
  inline void Swap(Gps* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gps* New() const final {
    return CreateMaybeMessage<Gps>(nullptr);
  }

  Gps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gps& from);
  void MergeFrom(const Gps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Gps";
  }
  protected:
  explicit Gps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGpggaFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kLatitudeFieldNumber = 3,
    kLongitudeFieldNumber = 5,
    kIsNorthFieldNumber = 4,
    kIsEastFieldNumber = 6,
    kGpsQualityFieldNumber = 7,
    kHorizontalDilutionOfPrecisionFieldNumber = 9,
    kAntennaAltitudeMetersFieldNumber = 10,
    kNumberOfSatellitesInUseFieldNumber = 8,
    kDifferentialReferenceStationIDFieldNumber = 13,
    kGeoidalSeparationMetersFieldNumber = 11,
    kAgeOfDifferentialGPSDataSecondsFieldNumber = 12,
  };
  // string gpgga = 2;
  void clear_gpgga();
  const std::string& gpgga() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gpgga(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gpgga();
  std::string* release_gpgga();
  void set_allocated_gpgga(std::string* gpgga);
  private:
  const std::string& _internal_gpgga() const;
  void _internal_set_gpgga(const std::string& value);
  std::string* _internal_mutable_gpgga();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // optional double latitude = 3;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // optional double longitude = 5;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // optional bool isNorth = 4;
  bool has_isnorth() const;
  private:
  bool _internal_has_isnorth() const;
  public:
  void clear_isnorth();
  bool isnorth() const;
  void set_isnorth(bool value);
  private:
  bool _internal_isnorth() const;
  void _internal_set_isnorth(bool value);
  public:

  // optional bool isEast = 6;
  bool has_iseast() const;
  private:
  bool _internal_has_iseast() const;
  public:
  void clear_iseast();
  bool iseast() const;
  void set_iseast(bool value);
  private:
  bool _internal_iseast() const;
  void _internal_set_iseast(bool value);
  public:

  // optional int32 gpsQuality = 7;
  bool has_gpsquality() const;
  private:
  bool _internal_has_gpsquality() const;
  public:
  void clear_gpsquality();
  ::PROTOBUF_NAMESPACE_ID::int32 gpsquality() const;
  void set_gpsquality(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gpsquality() const;
  void _internal_set_gpsquality(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double horizontalDilutionOfPrecision = 9;
  bool has_horizontaldilutionofprecision() const;
  private:
  bool _internal_has_horizontaldilutionofprecision() const;
  public:
  void clear_horizontaldilutionofprecision();
  double horizontaldilutionofprecision() const;
  void set_horizontaldilutionofprecision(double value);
  private:
  double _internal_horizontaldilutionofprecision() const;
  void _internal_set_horizontaldilutionofprecision(double value);
  public:

  // optional double antennaAltitudeMeters = 10;
  bool has_antennaaltitudemeters() const;
  private:
  bool _internal_has_antennaaltitudemeters() const;
  public:
  void clear_antennaaltitudemeters();
  double antennaaltitudemeters() const;
  void set_antennaaltitudemeters(double value);
  private:
  double _internal_antennaaltitudemeters() const;
  void _internal_set_antennaaltitudemeters(double value);
  public:

  // optional int32 numberOfSatellitesInUse = 8;
  bool has_numberofsatellitesinuse() const;
  private:
  bool _internal_has_numberofsatellitesinuse() const;
  public:
  void clear_numberofsatellitesinuse();
  ::PROTOBUF_NAMESPACE_ID::int32 numberofsatellitesinuse() const;
  void set_numberofsatellitesinuse(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numberofsatellitesinuse() const;
  void _internal_set_numberofsatellitesinuse(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 differentialReferenceStationID = 13;
  bool has_differentialreferencestationid() const;
  private:
  bool _internal_has_differentialreferencestationid() const;
  public:
  void clear_differentialreferencestationid();
  ::PROTOBUF_NAMESPACE_ID::int32 differentialreferencestationid() const;
  void set_differentialreferencestationid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_differentialreferencestationid() const;
  void _internal_set_differentialreferencestationid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double geoidalSeparationMeters = 11;
  bool has_geoidalseparationmeters() const;
  private:
  bool _internal_has_geoidalseparationmeters() const;
  public:
  void clear_geoidalseparationmeters();
  double geoidalseparationmeters() const;
  void set_geoidalseparationmeters(double value);
  private:
  double _internal_geoidalseparationmeters() const;
  void _internal_set_geoidalseparationmeters(double value);
  public:

  // optional double ageOfDifferentialGPSDataSeconds = 12;
  bool has_ageofdifferentialgpsdataseconds() const;
  private:
  bool _internal_has_ageofdifferentialgpsdataseconds() const;
  public:
  void clear_ageofdifferentialgpsdataseconds();
  double ageofdifferentialgpsdataseconds() const;
  void set_ageofdifferentialgpsdataseconds(double value);
  private:
  double _internal_ageofdifferentialgpsdataseconds() const;
  void _internal_set_ageofdifferentialgpsdataseconds(double value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Gps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gpgga_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  double latitude_;
  double longitude_;
  bool isnorth_;
  bool iseast_;
  ::PROTOBUF_NAMESPACE_ID::int32 gpsquality_;
  double horizontaldilutionofprecision_;
  double antennaaltitudemeters_;
  ::PROTOBUF_NAMESPACE_ID::int32 numberofsatellitesinuse_;
  ::PROTOBUF_NAMESPACE_ID::int32 differentialreferencestationid_;
  double geoidalseparationmeters_;
  double ageofdifferentialgpsdataseconds_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Imu PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Imu) */ {
 public:
  inline Imu() : Imu(nullptr) {}
  ~Imu() override;
  explicit constexpr Imu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Imu(const Imu& from);
  Imu(Imu&& from) noexcept
    : Imu() {
    *this = ::std::move(from);
  }

  inline Imu& operator=(const Imu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Imu& operator=(Imu&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Imu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Imu* internal_default_instance() {
    return reinterpret_cast<const Imu*>(
               &_Imu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Imu& a, Imu& b) {
    a.Swap(&b);
  }
  inline void Swap(Imu* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Imu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Imu* New() const final {
    return CreateMaybeMessage<Imu>(nullptr);
  }

  Imu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Imu>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Imu& from);
  void MergeFrom(const Imu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Imu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Imu";
  }
  protected:
  explicit Imu(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kScaledAccelXFieldNumber = 2,
    kScaledAccelYFieldNumber = 3,
    kScaledAccelZFieldNumber = 4,
    kScaledGyroXFieldNumber = 5,
    kScaledGyroYFieldNumber = 6,
    kScaledGyroZFieldNumber = 7,
    kScaledMagXFieldNumber = 8,
    kScaledMagYFieldNumber = 9,
    kScaledMagZFieldNumber = 10,
    kEstRollFieldNumber = 11,
    kEstPitchFieldNumber = 12,
    kEstYawFieldNumber = 13,
    kEstRollUncertFieldNumber = 14,
    kEstPitchUncertFieldNumber = 15,
    kEstYawUncertFieldNumber = 16,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // optional float scaledAccelX = 2;
  bool has_scaledaccelx() const;
  private:
  bool _internal_has_scaledaccelx() const;
  public:
  void clear_scaledaccelx();
  float scaledaccelx() const;
  void set_scaledaccelx(float value);
  private:
  float _internal_scaledaccelx() const;
  void _internal_set_scaledaccelx(float value);
  public:

  // optional float scaledAccelY = 3;
  bool has_scaledaccely() const;
  private:
  bool _internal_has_scaledaccely() const;
  public:
  void clear_scaledaccely();
  float scaledaccely() const;
  void set_scaledaccely(float value);
  private:
  float _internal_scaledaccely() const;
  void _internal_set_scaledaccely(float value);
  public:

  // optional float scaledAccelZ = 4;
  bool has_scaledaccelz() const;
  private:
  bool _internal_has_scaledaccelz() const;
  public:
  void clear_scaledaccelz();
  float scaledaccelz() const;
  void set_scaledaccelz(float value);
  private:
  float _internal_scaledaccelz() const;
  void _internal_set_scaledaccelz(float value);
  public:

  // optional float scaledGyroX = 5;
  bool has_scaledgyrox() const;
  private:
  bool _internal_has_scaledgyrox() const;
  public:
  void clear_scaledgyrox();
  float scaledgyrox() const;
  void set_scaledgyrox(float value);
  private:
  float _internal_scaledgyrox() const;
  void _internal_set_scaledgyrox(float value);
  public:

  // optional float scaledGyroY = 6;
  bool has_scaledgyroy() const;
  private:
  bool _internal_has_scaledgyroy() const;
  public:
  void clear_scaledgyroy();
  float scaledgyroy() const;
  void set_scaledgyroy(float value);
  private:
  float _internal_scaledgyroy() const;
  void _internal_set_scaledgyroy(float value);
  public:

  // optional float scaledGyroZ = 7;
  bool has_scaledgyroz() const;
  private:
  bool _internal_has_scaledgyroz() const;
  public:
  void clear_scaledgyroz();
  float scaledgyroz() const;
  void set_scaledgyroz(float value);
  private:
  float _internal_scaledgyroz() const;
  void _internal_set_scaledgyroz(float value);
  public:

  // optional float scaledMagX = 8;
  bool has_scaledmagx() const;
  private:
  bool _internal_has_scaledmagx() const;
  public:
  void clear_scaledmagx();
  float scaledmagx() const;
  void set_scaledmagx(float value);
  private:
  float _internal_scaledmagx() const;
  void _internal_set_scaledmagx(float value);
  public:

  // optional float scaledMagY = 9;
  bool has_scaledmagy() const;
  private:
  bool _internal_has_scaledmagy() const;
  public:
  void clear_scaledmagy();
  float scaledmagy() const;
  void set_scaledmagy(float value);
  private:
  float _internal_scaledmagy() const;
  void _internal_set_scaledmagy(float value);
  public:

  // optional float scaledMagZ = 10;
  bool has_scaledmagz() const;
  private:
  bool _internal_has_scaledmagz() const;
  public:
  void clear_scaledmagz();
  float scaledmagz() const;
  void set_scaledmagz(float value);
  private:
  float _internal_scaledmagz() const;
  void _internal_set_scaledmagz(float value);
  public:

  // optional float estRoll = 11;
  bool has_estroll() const;
  private:
  bool _internal_has_estroll() const;
  public:
  void clear_estroll();
  float estroll() const;
  void set_estroll(float value);
  private:
  float _internal_estroll() const;
  void _internal_set_estroll(float value);
  public:

  // optional float estPitch = 12;
  bool has_estpitch() const;
  private:
  bool _internal_has_estpitch() const;
  public:
  void clear_estpitch();
  float estpitch() const;
  void set_estpitch(float value);
  private:
  float _internal_estpitch() const;
  void _internal_set_estpitch(float value);
  public:

  // optional float estYaw = 13;
  bool has_estyaw() const;
  private:
  bool _internal_has_estyaw() const;
  public:
  void clear_estyaw();
  float estyaw() const;
  void set_estyaw(float value);
  private:
  float _internal_estyaw() const;
  void _internal_set_estyaw(float value);
  public:

  // optional float estRollUncert = 14;
  bool has_estrolluncert() const;
  private:
  bool _internal_has_estrolluncert() const;
  public:
  void clear_estrolluncert();
  float estrolluncert() const;
  void set_estrolluncert(float value);
  private:
  float _internal_estrolluncert() const;
  void _internal_set_estrolluncert(float value);
  public:

  // optional float estPitchUncert = 15;
  bool has_estpitchuncert() const;
  private:
  bool _internal_has_estpitchuncert() const;
  public:
  void clear_estpitchuncert();
  float estpitchuncert() const;
  void set_estpitchuncert(float value);
  private:
  float _internal_estpitchuncert() const;
  void _internal_set_estpitchuncert(float value);
  public:

  // optional float estYawUncert = 16;
  bool has_estyawuncert() const;
  private:
  bool _internal_has_estyawuncert() const;
  public:
  void clear_estyawuncert();
  float estyawuncert() const;
  void set_estyawuncert(float value);
  private:
  float _internal_estyawuncert() const;
  void _internal_set_estyawuncert(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Imu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  float scaledaccelx_;
  float scaledaccely_;
  float scaledaccelz_;
  float scaledgyrox_;
  float scaledgyroy_;
  float scaledgyroz_;
  float scaledmagx_;
  float scaledmagy_;
  float scaledmagz_;
  float estroll_;
  float estpitch_;
  float estyaw_;
  float estrolluncert_;
  float estpitchuncert_;
  float estyawuncert_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Cam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Cam) */ {
 public:
  inline Cam() : Cam(nullptr) {}
  ~Cam() override;
  explicit constexpr Cam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cam(const Cam& from);
  Cam(Cam&& from) noexcept
    : Cam() {
    *this = ::std::move(from);
  }

  inline Cam& operator=(const Cam& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cam& operator=(Cam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cam& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cam* internal_default_instance() {
    return reinterpret_cast<const Cam*>(
               &_Cam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Cam& a, Cam& b) {
    a.Swap(&b);
  }
  inline void Swap(Cam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cam* New() const final {
    return CreateMaybeMessage<Cam>(nullptr);
  }

  Cam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cam& from);
  void MergeFrom(const Cam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Cam";
  }
  protected:
  explicit Cam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedDataFieldNumber = 5,
    kGreenDataFieldNumber = 6,
    kBlueDataFieldNumber = 7,
    kImageDataFieldNumber = 8,
    kTimestampFieldNumber = 1,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // bytes red_data = 5;
  void clear_red_data();
  const std::string& red_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_red_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_red_data();
  std::string* release_red_data();
  void set_allocated_red_data(std::string* red_data);
  private:
  const std::string& _internal_red_data() const;
  void _internal_set_red_data(const std::string& value);
  std::string* _internal_mutable_red_data();
  public:

  // bytes green_data = 6;
  void clear_green_data();
  const std::string& green_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_green_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_green_data();
  std::string* release_green_data();
  void set_allocated_green_data(std::string* green_data);
  private:
  const std::string& _internal_green_data() const;
  void _internal_set_green_data(const std::string& value);
  std::string* _internal_mutable_green_data();
  public:

  // bytes blue_data = 7;
  void clear_blue_data();
  const std::string& blue_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blue_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blue_data();
  std::string* release_blue_data();
  void set_allocated_blue_data(std::string* blue_data);
  private:
  const std::string& _internal_blue_data() const;
  void _internal_set_blue_data(const std::string& value);
  std::string* _internal_mutable_blue_data();
  public:

  // bytes image_data = 8;
  void clear_image_data();
  const std::string& image_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_data();
  std::string* release_image_data();
  void set_allocated_image_data(std::string* image_data);
  private:
  const std::string& _internal_image_data() const;
  void _internal_set_image_data(const std::string& value);
  std::string* _internal_mutable_image_data();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int32 type = 2;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Cam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr red_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr green_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blue_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Lidar PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Lidar) */ {
 public:
  inline Lidar() : Lidar(nullptr) {}
  ~Lidar() override;
  explicit constexpr Lidar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lidar(const Lidar& from);
  Lidar(Lidar&& from) noexcept
    : Lidar() {
    *this = ::std::move(from);
  }

  inline Lidar& operator=(const Lidar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lidar& operator=(Lidar&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lidar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lidar* internal_default_instance() {
    return reinterpret_cast<const Lidar*>(
               &_Lidar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Lidar& a, Lidar& b) {
    a.Swap(&b);
  }
  inline void Swap(Lidar* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lidar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lidar* New() const final {
    return CreateMaybeMessage<Lidar>(nullptr);
  }

  Lidar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lidar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lidar& from);
  void MergeFrom(const Lidar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lidar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Lidar";
  }
  protected:
  explicit Lidar(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.Lidar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Can PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Can) */ {
 public:
  inline Can() : Can(nullptr) {}
  ~Can() override;
  explicit constexpr Can(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Can(const Can& from);
  Can(Can&& from) noexcept
    : Can() {
    *this = ::std::move(from);
  }

  inline Can& operator=(const Can& from) {
    CopyFrom(from);
    return *this;
  }
  inline Can& operator=(Can&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Can& default_instance() {
    return *internal_default_instance();
  }
  static inline const Can* internal_default_instance() {
    return reinterpret_cast<const Can*>(
               &_Can_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Can& a, Can& b) {
    a.Swap(&b);
  }
  inline void Swap(Can* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Can* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Can* New() const final {
    return CreateMaybeMessage<Can>(nullptr);
  }

  Can* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Can>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Can& from);
  void MergeFrom(const Can& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Can* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Can";
  }
  protected:
  explicit Can(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.Can)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gps

// .google.protobuf.Timestamp timestamp = 1;
inline bool Gps::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Gps::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Gps::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Gps::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.timestamp)
  return _internal_timestamp();
}
inline void Gps::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.Gps.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Gps::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Gps::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.Gps.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Gps::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Gps::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:sensors.Gps.timestamp)
  return _internal_mutable_timestamp();
}
inline void Gps::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.Gps.timestamp)
}

// string gpgga = 2;
inline void Gps::clear_gpgga() {
  gpgga_.ClearToEmpty();
}
inline const std::string& Gps::gpgga() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.gpgga)
  return _internal_gpgga();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Gps::set_gpgga(ArgT0&& arg0, ArgT... args) {
 
 gpgga_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Gps.gpgga)
}
inline std::string* Gps::mutable_gpgga() {
  // @@protoc_insertion_point(field_mutable:sensors.Gps.gpgga)
  return _internal_mutable_gpgga();
}
inline const std::string& Gps::_internal_gpgga() const {
  return gpgga_.Get();
}
inline void Gps::_internal_set_gpgga(const std::string& value) {
  
  gpgga_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Gps::_internal_mutable_gpgga() {
  
  return gpgga_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Gps::release_gpgga() {
  // @@protoc_insertion_point(field_release:sensors.Gps.gpgga)
  return gpgga_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Gps::set_allocated_gpgga(std::string* gpgga) {
  if (gpgga != nullptr) {
    
  } else {
    
  }
  gpgga_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gpgga,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Gps.gpgga)
}

// optional double latitude = 3;
inline bool Gps::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gps::has_latitude() const {
  return _internal_has_latitude();
}
inline void Gps::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Gps::_internal_latitude() const {
  return latitude_;
}
inline double Gps::latitude() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.latitude)
  return _internal_latitude();
}
inline void Gps::_internal_set_latitude(double value) {
  _has_bits_[0] |= 0x00000001u;
  latitude_ = value;
}
inline void Gps::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.latitude)
}

// optional bool isNorth = 4;
inline bool Gps::_internal_has_isnorth() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Gps::has_isnorth() const {
  return _internal_has_isnorth();
}
inline void Gps::clear_isnorth() {
  isnorth_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Gps::_internal_isnorth() const {
  return isnorth_;
}
inline bool Gps::isnorth() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.isNorth)
  return _internal_isnorth();
}
inline void Gps::_internal_set_isnorth(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isnorth_ = value;
}
inline void Gps::set_isnorth(bool value) {
  _internal_set_isnorth(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.isNorth)
}

// optional double longitude = 5;
inline bool Gps::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Gps::has_longitude() const {
  return _internal_has_longitude();
}
inline void Gps::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Gps::_internal_longitude() const {
  return longitude_;
}
inline double Gps::longitude() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.longitude)
  return _internal_longitude();
}
inline void Gps::_internal_set_longitude(double value) {
  _has_bits_[0] |= 0x00000002u;
  longitude_ = value;
}
inline void Gps::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.longitude)
}

// optional bool isEast = 6;
inline bool Gps::_internal_has_iseast() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Gps::has_iseast() const {
  return _internal_has_iseast();
}
inline void Gps::clear_iseast() {
  iseast_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Gps::_internal_iseast() const {
  return iseast_;
}
inline bool Gps::iseast() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.isEast)
  return _internal_iseast();
}
inline void Gps::_internal_set_iseast(bool value) {
  _has_bits_[0] |= 0x00000008u;
  iseast_ = value;
}
inline void Gps::set_iseast(bool value) {
  _internal_set_iseast(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.isEast)
}

// optional int32 gpsQuality = 7;
inline bool Gps::_internal_has_gpsquality() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Gps::has_gpsquality() const {
  return _internal_has_gpsquality();
}
inline void Gps::clear_gpsquality() {
  gpsquality_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gps::_internal_gpsquality() const {
  return gpsquality_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gps::gpsquality() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.gpsQuality)
  return _internal_gpsquality();
}
inline void Gps::_internal_set_gpsquality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  gpsquality_ = value;
}
inline void Gps::set_gpsquality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gpsquality(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.gpsQuality)
}

// optional int32 numberOfSatellitesInUse = 8;
inline bool Gps::_internal_has_numberofsatellitesinuse() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Gps::has_numberofsatellitesinuse() const {
  return _internal_has_numberofsatellitesinuse();
}
inline void Gps::clear_numberofsatellitesinuse() {
  numberofsatellitesinuse_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gps::_internal_numberofsatellitesinuse() const {
  return numberofsatellitesinuse_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gps::numberofsatellitesinuse() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.numberOfSatellitesInUse)
  return _internal_numberofsatellitesinuse();
}
inline void Gps::_internal_set_numberofsatellitesinuse(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  numberofsatellitesinuse_ = value;
}
inline void Gps::set_numberofsatellitesinuse(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_numberofsatellitesinuse(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.numberOfSatellitesInUse)
}

// optional double horizontalDilutionOfPrecision = 9;
inline bool Gps::_internal_has_horizontaldilutionofprecision() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Gps::has_horizontaldilutionofprecision() const {
  return _internal_has_horizontaldilutionofprecision();
}
inline void Gps::clear_horizontaldilutionofprecision() {
  horizontaldilutionofprecision_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double Gps::_internal_horizontaldilutionofprecision() const {
  return horizontaldilutionofprecision_;
}
inline double Gps::horizontaldilutionofprecision() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.horizontalDilutionOfPrecision)
  return _internal_horizontaldilutionofprecision();
}
inline void Gps::_internal_set_horizontaldilutionofprecision(double value) {
  _has_bits_[0] |= 0x00000020u;
  horizontaldilutionofprecision_ = value;
}
inline void Gps::set_horizontaldilutionofprecision(double value) {
  _internal_set_horizontaldilutionofprecision(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.horizontalDilutionOfPrecision)
}

// optional double antennaAltitudeMeters = 10;
inline bool Gps::_internal_has_antennaaltitudemeters() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Gps::has_antennaaltitudemeters() const {
  return _internal_has_antennaaltitudemeters();
}
inline void Gps::clear_antennaaltitudemeters() {
  antennaaltitudemeters_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Gps::_internal_antennaaltitudemeters() const {
  return antennaaltitudemeters_;
}
inline double Gps::antennaaltitudemeters() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.antennaAltitudeMeters)
  return _internal_antennaaltitudemeters();
}
inline void Gps::_internal_set_antennaaltitudemeters(double value) {
  _has_bits_[0] |= 0x00000040u;
  antennaaltitudemeters_ = value;
}
inline void Gps::set_antennaaltitudemeters(double value) {
  _internal_set_antennaaltitudemeters(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.antennaAltitudeMeters)
}

// optional double geoidalSeparationMeters = 11;
inline bool Gps::_internal_has_geoidalseparationmeters() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Gps::has_geoidalseparationmeters() const {
  return _internal_has_geoidalseparationmeters();
}
inline void Gps::clear_geoidalseparationmeters() {
  geoidalseparationmeters_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double Gps::_internal_geoidalseparationmeters() const {
  return geoidalseparationmeters_;
}
inline double Gps::geoidalseparationmeters() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.geoidalSeparationMeters)
  return _internal_geoidalseparationmeters();
}
inline void Gps::_internal_set_geoidalseparationmeters(double value) {
  _has_bits_[0] |= 0x00000200u;
  geoidalseparationmeters_ = value;
}
inline void Gps::set_geoidalseparationmeters(double value) {
  _internal_set_geoidalseparationmeters(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.geoidalSeparationMeters)
}

// optional double ageOfDifferentialGPSDataSeconds = 12;
inline bool Gps::_internal_has_ageofdifferentialgpsdataseconds() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Gps::has_ageofdifferentialgpsdataseconds() const {
  return _internal_has_ageofdifferentialgpsdataseconds();
}
inline void Gps::clear_ageofdifferentialgpsdataseconds() {
  ageofdifferentialgpsdataseconds_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double Gps::_internal_ageofdifferentialgpsdataseconds() const {
  return ageofdifferentialgpsdataseconds_;
}
inline double Gps::ageofdifferentialgpsdataseconds() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.ageOfDifferentialGPSDataSeconds)
  return _internal_ageofdifferentialgpsdataseconds();
}
inline void Gps::_internal_set_ageofdifferentialgpsdataseconds(double value) {
  _has_bits_[0] |= 0x00000400u;
  ageofdifferentialgpsdataseconds_ = value;
}
inline void Gps::set_ageofdifferentialgpsdataseconds(double value) {
  _internal_set_ageofdifferentialgpsdataseconds(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.ageOfDifferentialGPSDataSeconds)
}

// optional int32 differentialReferenceStationID = 13;
inline bool Gps::_internal_has_differentialreferencestationid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Gps::has_differentialreferencestationid() const {
  return _internal_has_differentialreferencestationid();
}
inline void Gps::clear_differentialreferencestationid() {
  differentialreferencestationid_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gps::_internal_differentialreferencestationid() const {
  return differentialreferencestationid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gps::differentialreferencestationid() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.differentialReferenceStationID)
  return _internal_differentialreferencestationid();
}
inline void Gps::_internal_set_differentialreferencestationid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  differentialreferencestationid_ = value;
}
inline void Gps::set_differentialreferencestationid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_differentialreferencestationid(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.differentialReferenceStationID)
}

// -------------------------------------------------------------------

// Imu

// .google.protobuf.Timestamp timestamp = 1;
inline bool Imu::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Imu::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Imu::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Imu::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.timestamp)
  return _internal_timestamp();
}
inline void Imu::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.Imu.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Imu::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Imu::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.Imu.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Imu::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Imu::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:sensors.Imu.timestamp)
  return _internal_mutable_timestamp();
}
inline void Imu::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.Imu.timestamp)
}

// optional float scaledAccelX = 2;
inline bool Imu::_internal_has_scaledaccelx() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Imu::has_scaledaccelx() const {
  return _internal_has_scaledaccelx();
}
inline void Imu::clear_scaledaccelx() {
  scaledaccelx_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Imu::_internal_scaledaccelx() const {
  return scaledaccelx_;
}
inline float Imu::scaledaccelx() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelX)
  return _internal_scaledaccelx();
}
inline void Imu::_internal_set_scaledaccelx(float value) {
  _has_bits_[0] |= 0x00000001u;
  scaledaccelx_ = value;
}
inline void Imu::set_scaledaccelx(float value) {
  _internal_set_scaledaccelx(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelX)
}

// optional float scaledAccelY = 3;
inline bool Imu::_internal_has_scaledaccely() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Imu::has_scaledaccely() const {
  return _internal_has_scaledaccely();
}
inline void Imu::clear_scaledaccely() {
  scaledaccely_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Imu::_internal_scaledaccely() const {
  return scaledaccely_;
}
inline float Imu::scaledaccely() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelY)
  return _internal_scaledaccely();
}
inline void Imu::_internal_set_scaledaccely(float value) {
  _has_bits_[0] |= 0x00000002u;
  scaledaccely_ = value;
}
inline void Imu::set_scaledaccely(float value) {
  _internal_set_scaledaccely(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelY)
}

// optional float scaledAccelZ = 4;
inline bool Imu::_internal_has_scaledaccelz() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Imu::has_scaledaccelz() const {
  return _internal_has_scaledaccelz();
}
inline void Imu::clear_scaledaccelz() {
  scaledaccelz_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Imu::_internal_scaledaccelz() const {
  return scaledaccelz_;
}
inline float Imu::scaledaccelz() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelZ)
  return _internal_scaledaccelz();
}
inline void Imu::_internal_set_scaledaccelz(float value) {
  _has_bits_[0] |= 0x00000004u;
  scaledaccelz_ = value;
}
inline void Imu::set_scaledaccelz(float value) {
  _internal_set_scaledaccelz(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelZ)
}

// optional float scaledGyroX = 5;
inline bool Imu::_internal_has_scaledgyrox() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Imu::has_scaledgyrox() const {
  return _internal_has_scaledgyrox();
}
inline void Imu::clear_scaledgyrox() {
  scaledgyrox_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Imu::_internal_scaledgyrox() const {
  return scaledgyrox_;
}
inline float Imu::scaledgyrox() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledGyroX)
  return _internal_scaledgyrox();
}
inline void Imu::_internal_set_scaledgyrox(float value) {
  _has_bits_[0] |= 0x00000008u;
  scaledgyrox_ = value;
}
inline void Imu::set_scaledgyrox(float value) {
  _internal_set_scaledgyrox(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledGyroX)
}

// optional float scaledGyroY = 6;
inline bool Imu::_internal_has_scaledgyroy() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Imu::has_scaledgyroy() const {
  return _internal_has_scaledgyroy();
}
inline void Imu::clear_scaledgyroy() {
  scaledgyroy_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Imu::_internal_scaledgyroy() const {
  return scaledgyroy_;
}
inline float Imu::scaledgyroy() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledGyroY)
  return _internal_scaledgyroy();
}
inline void Imu::_internal_set_scaledgyroy(float value) {
  _has_bits_[0] |= 0x00000010u;
  scaledgyroy_ = value;
}
inline void Imu::set_scaledgyroy(float value) {
  _internal_set_scaledgyroy(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledGyroY)
}

// optional float scaledGyroZ = 7;
inline bool Imu::_internal_has_scaledgyroz() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Imu::has_scaledgyroz() const {
  return _internal_has_scaledgyroz();
}
inline void Imu::clear_scaledgyroz() {
  scaledgyroz_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Imu::_internal_scaledgyroz() const {
  return scaledgyroz_;
}
inline float Imu::scaledgyroz() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledGyroZ)
  return _internal_scaledgyroz();
}
inline void Imu::_internal_set_scaledgyroz(float value) {
  _has_bits_[0] |= 0x00000020u;
  scaledgyroz_ = value;
}
inline void Imu::set_scaledgyroz(float value) {
  _internal_set_scaledgyroz(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledGyroZ)
}

// optional float scaledMagX = 8;
inline bool Imu::_internal_has_scaledmagx() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Imu::has_scaledmagx() const {
  return _internal_has_scaledmagx();
}
inline void Imu::clear_scaledmagx() {
  scaledmagx_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Imu::_internal_scaledmagx() const {
  return scaledmagx_;
}
inline float Imu::scaledmagx() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledMagX)
  return _internal_scaledmagx();
}
inline void Imu::_internal_set_scaledmagx(float value) {
  _has_bits_[0] |= 0x00000040u;
  scaledmagx_ = value;
}
inline void Imu::set_scaledmagx(float value) {
  _internal_set_scaledmagx(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledMagX)
}

// optional float scaledMagY = 9;
inline bool Imu::_internal_has_scaledmagy() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Imu::has_scaledmagy() const {
  return _internal_has_scaledmagy();
}
inline void Imu::clear_scaledmagy() {
  scaledmagy_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Imu::_internal_scaledmagy() const {
  return scaledmagy_;
}
inline float Imu::scaledmagy() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledMagY)
  return _internal_scaledmagy();
}
inline void Imu::_internal_set_scaledmagy(float value) {
  _has_bits_[0] |= 0x00000080u;
  scaledmagy_ = value;
}
inline void Imu::set_scaledmagy(float value) {
  _internal_set_scaledmagy(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledMagY)
}

// optional float scaledMagZ = 10;
inline bool Imu::_internal_has_scaledmagz() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Imu::has_scaledmagz() const {
  return _internal_has_scaledmagz();
}
inline void Imu::clear_scaledmagz() {
  scaledmagz_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Imu::_internal_scaledmagz() const {
  return scaledmagz_;
}
inline float Imu::scaledmagz() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledMagZ)
  return _internal_scaledmagz();
}
inline void Imu::_internal_set_scaledmagz(float value) {
  _has_bits_[0] |= 0x00000100u;
  scaledmagz_ = value;
}
inline void Imu::set_scaledmagz(float value) {
  _internal_set_scaledmagz(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledMagZ)
}

// optional float estRoll = 11;
inline bool Imu::_internal_has_estroll() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Imu::has_estroll() const {
  return _internal_has_estroll();
}
inline void Imu::clear_estroll() {
  estroll_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Imu::_internal_estroll() const {
  return estroll_;
}
inline float Imu::estroll() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.estRoll)
  return _internal_estroll();
}
inline void Imu::_internal_set_estroll(float value) {
  _has_bits_[0] |= 0x00000200u;
  estroll_ = value;
}
inline void Imu::set_estroll(float value) {
  _internal_set_estroll(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.estRoll)
}

// optional float estPitch = 12;
inline bool Imu::_internal_has_estpitch() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Imu::has_estpitch() const {
  return _internal_has_estpitch();
}
inline void Imu::clear_estpitch() {
  estpitch_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Imu::_internal_estpitch() const {
  return estpitch_;
}
inline float Imu::estpitch() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.estPitch)
  return _internal_estpitch();
}
inline void Imu::_internal_set_estpitch(float value) {
  _has_bits_[0] |= 0x00000400u;
  estpitch_ = value;
}
inline void Imu::set_estpitch(float value) {
  _internal_set_estpitch(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.estPitch)
}

// optional float estYaw = 13;
inline bool Imu::_internal_has_estyaw() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Imu::has_estyaw() const {
  return _internal_has_estyaw();
}
inline void Imu::clear_estyaw() {
  estyaw_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float Imu::_internal_estyaw() const {
  return estyaw_;
}
inline float Imu::estyaw() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.estYaw)
  return _internal_estyaw();
}
inline void Imu::_internal_set_estyaw(float value) {
  _has_bits_[0] |= 0x00000800u;
  estyaw_ = value;
}
inline void Imu::set_estyaw(float value) {
  _internal_set_estyaw(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.estYaw)
}

// optional float estRollUncert = 14;
inline bool Imu::_internal_has_estrolluncert() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Imu::has_estrolluncert() const {
  return _internal_has_estrolluncert();
}
inline void Imu::clear_estrolluncert() {
  estrolluncert_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float Imu::_internal_estrolluncert() const {
  return estrolluncert_;
}
inline float Imu::estrolluncert() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.estRollUncert)
  return _internal_estrolluncert();
}
inline void Imu::_internal_set_estrolluncert(float value) {
  _has_bits_[0] |= 0x00001000u;
  estrolluncert_ = value;
}
inline void Imu::set_estrolluncert(float value) {
  _internal_set_estrolluncert(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.estRollUncert)
}

// optional float estPitchUncert = 15;
inline bool Imu::_internal_has_estpitchuncert() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Imu::has_estpitchuncert() const {
  return _internal_has_estpitchuncert();
}
inline void Imu::clear_estpitchuncert() {
  estpitchuncert_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float Imu::_internal_estpitchuncert() const {
  return estpitchuncert_;
}
inline float Imu::estpitchuncert() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.estPitchUncert)
  return _internal_estpitchuncert();
}
inline void Imu::_internal_set_estpitchuncert(float value) {
  _has_bits_[0] |= 0x00002000u;
  estpitchuncert_ = value;
}
inline void Imu::set_estpitchuncert(float value) {
  _internal_set_estpitchuncert(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.estPitchUncert)
}

// optional float estYawUncert = 16;
inline bool Imu::_internal_has_estyawuncert() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Imu::has_estyawuncert() const {
  return _internal_has_estyawuncert();
}
inline void Imu::clear_estyawuncert() {
  estyawuncert_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float Imu::_internal_estyawuncert() const {
  return estyawuncert_;
}
inline float Imu::estyawuncert() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.estYawUncert)
  return _internal_estyawuncert();
}
inline void Imu::_internal_set_estyawuncert(float value) {
  _has_bits_[0] |= 0x00004000u;
  estyawuncert_ = value;
}
inline void Imu::set_estyawuncert(float value) {
  _internal_set_estyawuncert(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.estYawUncert)
}

// -------------------------------------------------------------------

// Cam

// .google.protobuf.Timestamp timestamp = 1;
inline bool Cam::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Cam::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Cam::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Cam::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.timestamp)
  return _internal_timestamp();
}
inline void Cam::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.Cam.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Cam::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Cam::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.Cam.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Cam::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Cam::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.timestamp)
  return _internal_mutable_timestamp();
}
inline void Cam::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.timestamp)
}

// int32 type = 2;
inline void Cam::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::type() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.type)
  return _internal_type();
}
inline void Cam::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void Cam::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.type)
}

// int32 width = 3;
inline void Cam::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::width() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.width)
  return _internal_width();
}
inline void Cam::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Cam::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.width)
}

// int32 height = 4;
inline void Cam::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::height() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.height)
  return _internal_height();
}
inline void Cam::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Cam::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.height)
}

// bytes red_data = 5;
inline void Cam::clear_red_data() {
  red_data_.ClearToEmpty();
}
inline const std::string& Cam::red_data() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.red_data)
  return _internal_red_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Cam::set_red_data(ArgT0&& arg0, ArgT... args) {
 
 red_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Cam.red_data)
}
inline std::string* Cam::mutable_red_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.red_data)
  return _internal_mutable_red_data();
}
inline const std::string& Cam::_internal_red_data() const {
  return red_data_.Get();
}
inline void Cam::_internal_set_red_data(const std::string& value) {
  
  red_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Cam::_internal_mutable_red_data() {
  
  return red_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cam::release_red_data() {
  // @@protoc_insertion_point(field_release:sensors.Cam.red_data)
  return red_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cam::set_allocated_red_data(std::string* red_data) {
  if (red_data != nullptr) {
    
  } else {
    
  }
  red_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), red_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.red_data)
}

// bytes green_data = 6;
inline void Cam::clear_green_data() {
  green_data_.ClearToEmpty();
}
inline const std::string& Cam::green_data() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.green_data)
  return _internal_green_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Cam::set_green_data(ArgT0&& arg0, ArgT... args) {
 
 green_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Cam.green_data)
}
inline std::string* Cam::mutable_green_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.green_data)
  return _internal_mutable_green_data();
}
inline const std::string& Cam::_internal_green_data() const {
  return green_data_.Get();
}
inline void Cam::_internal_set_green_data(const std::string& value) {
  
  green_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Cam::_internal_mutable_green_data() {
  
  return green_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cam::release_green_data() {
  // @@protoc_insertion_point(field_release:sensors.Cam.green_data)
  return green_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cam::set_allocated_green_data(std::string* green_data) {
  if (green_data != nullptr) {
    
  } else {
    
  }
  green_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), green_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.green_data)
}

// bytes blue_data = 7;
inline void Cam::clear_blue_data() {
  blue_data_.ClearToEmpty();
}
inline const std::string& Cam::blue_data() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.blue_data)
  return _internal_blue_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Cam::set_blue_data(ArgT0&& arg0, ArgT... args) {
 
 blue_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Cam.blue_data)
}
inline std::string* Cam::mutable_blue_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.blue_data)
  return _internal_mutable_blue_data();
}
inline const std::string& Cam::_internal_blue_data() const {
  return blue_data_.Get();
}
inline void Cam::_internal_set_blue_data(const std::string& value) {
  
  blue_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Cam::_internal_mutable_blue_data() {
  
  return blue_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cam::release_blue_data() {
  // @@protoc_insertion_point(field_release:sensors.Cam.blue_data)
  return blue_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cam::set_allocated_blue_data(std::string* blue_data) {
  if (blue_data != nullptr) {
    
  } else {
    
  }
  blue_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blue_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.blue_data)
}

// bytes image_data = 8;
inline void Cam::clear_image_data() {
  image_data_.ClearToEmpty();
}
inline const std::string& Cam::image_data() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.image_data)
  return _internal_image_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Cam::set_image_data(ArgT0&& arg0, ArgT... args) {
 
 image_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Cam.image_data)
}
inline std::string* Cam::mutable_image_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.image_data)
  return _internal_mutable_image_data();
}
inline const std::string& Cam::_internal_image_data() const {
  return image_data_.Get();
}
inline void Cam::_internal_set_image_data(const std::string& value) {
  
  image_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Cam::_internal_mutable_image_data() {
  
  return image_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cam::release_image_data() {
  // @@protoc_insertion_point(field_release:sensors.Cam.image_data)
  return image_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cam::set_allocated_image_data(std::string* image_data) {
  if (image_data != nullptr) {
    
  } else {
    
  }
  image_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.image_data)
}

// -------------------------------------------------------------------

// Lidar

// .google.protobuf.Timestamp timestamp = 1;
inline bool Lidar::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Lidar::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Lidar::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Lidar::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.timestamp)
  return _internal_timestamp();
}
inline void Lidar::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.Lidar.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.Lidar.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lidar::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:sensors.Lidar.timestamp)
  return _internal_mutable_timestamp();
}
inline void Lidar::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.Lidar.timestamp)
}

// -------------------------------------------------------------------

// Can

// .google.protobuf.Timestamp timestamp = 1;
inline bool Can::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Can::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Can::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Can::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.Can.timestamp)
  return _internal_timestamp();
}
inline void Can::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.Can.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Can::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Can::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.Can.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Can::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Can::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:sensors.Can.timestamp)
  return _internal_mutable_timestamp();
}
inline void Can::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.Can.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sensors

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
